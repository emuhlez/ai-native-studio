# Studio Shell Game Editor - Cursor Rules

## Project Overview
Studio Shell is a modern game editor built with React, TypeScript, and Vite. It features a forge-inspired aesthetic with warm amber/copper accents on an industrial dark theme.

## Tech Stack
- React 18 with TypeScript
- Vite for build tooling
- Zustand for state management
- CSS Modules for component styling
- Lucide React for icons

## Development Workflow
- Build features piece-by-piece, not all at once
- After completing each discrete piece/component, commit the changes
- Move on to the next feature only after the current piece is committed
- This ensures incremental progress and makes it easier to track changes
- Each commit should represent a complete, functional unit of work

## Code Style & Conventions

### TypeScript
- Use strict TypeScript mode
- Always define proper types, avoid `any`
- Prefer interfaces over types for object shapes
- Use type inference where possible
- Export types from `src/types/index.ts`

### React
- Use functional components with hooks
- Prefer named exports for components
- Use meaningful component and variable names
- Keep components focused and single-responsibility
- Extract reusable logic into custom hooks

### File Structure
```
src/
├── components/
│   ├── shared/         # Reusable UI components
│   └── [Feature]/      # Feature-specific components
│       ├── [Feature].tsx
│       └── [Feature].module.css
├── store/              # Zustand stores
├── types/              # TypeScript type definitions
├── hooks/              # Custom React hooks
├── utils/              # Utility functions
└── styles/             # Global styles
```

### Naming Conventions
- Components: PascalCase (e.g., `GameObjectTree.tsx`)
- Hooks: camelCase with "use" prefix (e.g., `useEditorState`)
- Utilities: camelCase (e.g., `formatTransform`)
- CSS Modules: camelCase classes (e.g., `.panelHeader`)
- Constants: UPPER_SNAKE_CASE (e.g., `MAX_OBJECTS`)
- Types/Interfaces: PascalCase (e.g., `GameObject`, `Transform`)

### CSS & Styling
- Use CSS Modules for component-specific styles
- Use `styles.css` or `global.css` for shared utilities
- Follow BEM-like naming for CSS classes
- Use CSS variables from `:root` for colors, spacing, etc.
- Prefer flexbox and grid for layouts
- Mobile-first responsive design when applicable

### State Management
- Use Zustand for global application state
- Keep local state in components when possible
- Use derived state instead of duplicating data
- Actions should be co-located with state in stores
- Use selectors to access only needed state

### Component Patterns
- Extract shared UI components to `components/shared/`
- Use composition over inheritance
- Pass callbacks via props for child-to-parent communication
- Use context sparingly, prefer props drilling or Zustand
- Implement loading and error states

### Color Palette
Use these CSS variables consistently:
- Surfaces: `--bg-surface0` (#121215), `--bg-surface100` (#191A1F), `--bg-surface200` (#202227), `--bg-surface300` (#272930)
- Aliases: `--bg-panel` (surface100), `--bg-darkest` (surface0), `--bg-surface` (surface100)
- Accent: `--accent-primary` (#335FFF)
- Content: `--content-emphasis` (#F7F7F8), `--content-default` (#D5D7DD), `--content-muted` (#BCBEC8), `--content-link` (#528BFF)
- Semantic: `--color-success` (#39C582), `--color-warning` (#F2BA2A), `--color-error` (#DF281F), `--color-emphasis` (#335FFF)
- Borders: `--border-subtle` (white 6%), `--border-default` (white 10%), `--border-strong` (white 15%)

### Interaction States
All interactive elements (icons, buttons, list items) use these states built from #D0D9FB:
- **Hover**: `--content-hover` — `rgba(208, 217, 251, 0.08)` (#D0D9FB at 8%)
- **Pressed / Active**: `--content-pressed` — `rgba(208, 217, 251, 0.12)` (#D0D9FB at 12%)

Apply these as `background` on the element's `:hover` and `:active` pseudo-classes respectively. Example for an icon button:
```css
.iconButton:hover {
  background: var(--content-hover);
}
.iconButton:active {
  background: var(--content-pressed);
}
```

### Icons
- Use Lucide React for all icons
- Keep icon size consistent (12-24px typically)
- Use semantic icon names
- Color icons using CSS variables
- Always implement hover (`--content-hover`) and pressed (`--content-pressed`) background states on clickable icons

### Dropdowns & Menus
- **All dropdowns, menus, and popovers MUST stay fully within the viewport.** They must never trail off any edge of the screen.
- Use `useLayoutEffect` (not `useEffect`) to measure the element after render and apply corrective positioning before paint, so the user never sees a flash.
- For absolutely-positioned menus, apply a corrective `transform: translate(dx, dy)` to nudge the element back inside the viewport. See `clampToViewport()` in `MenuDropdown.tsx` for the canonical implementation.
- For submenus, flip horizontally (`left: auto; right: calc(100% - 4px)`) when overflowing the right edge, and use `translateY()` for vertical overflow.
- For fixed-positioned menus (e.g. FilterMenu), directly adjust `top`/`right` style properties to clamp within bounds.
- Always leave at least 8px padding from the viewport edges.
- The shared `ContextMenu` component already handles viewport clamping — do not duplicate that logic when `MenuDropdown` is rendered inside it (the clamp utility skips elements with `position: relative`).

### Accessibility
- Use semantic HTML elements
- Include ARIA labels where needed
- Ensure keyboard navigation works
- Maintain proper focus states
- Use sufficient color contrast

### Performance
- Memoize expensive computations with `useMemo`
- Use `useCallback` for callbacks passed to child components
- Lazy load components when appropriate
- Avoid unnecessary re-renders
- Profile before optimizing

### Error Handling
- Use try-catch for async operations
- Log errors to console in development
- Provide user-friendly error messages
- Handle edge cases gracefully
- Validate user input

### Testing Considerations
- Write testable code (pure functions, small components)
- Separate business logic from UI
- Use meaningful test IDs when needed
- Consider edge cases and error states

## Editor-Specific Guidelines

### Game Objects
- Every GameObject must have a unique ID
- Maintain parent-child relationships carefully
- Validate transforms before applying
- Support undo/redo for object operations

### Scene Hierarchy
- Support nested object structures
- Implement drag-and-drop for reparenting
- Show visual feedback for selections
- Maintain object visibility states

### Inspector Panel
- Show properties for selected object only
- Group related properties together
- Validate numeric inputs
- Provide sensible default values

### Viewport
- Render objects based on their transforms
- Show visual guides (grid, axes, etc.)
- Support multiple view modes (2D/3D)
- Optimize rendering for performance

### Assets
- Organize assets by type
- Support search and filtering
- Show thumbnails when applicable
- Handle missing assets gracefully

### Console
- Log all important operations
- Support different message types (log, warning, error)
- Show timestamps and sources
- Provide clear, actionable messages

## Git Conventions
- Use conventional commits format
- Write descriptive commit messages
- Keep commits focused and atomic
- Commit after each complete feature piece before moving to the next
- Each commit should be a working, testable unit
- Branch naming: `feature/`, `fix/`, `refactor/`

## Comments & Documentation
- Use JSDoc for public functions and components
- Explain "why" not "what" in comments
- Keep comments up-to-date
- Document complex algorithms
- Add README files for major features

## Dependencies
- Minimize external dependencies
- Keep dependencies up-to-date
- Prefer well-maintained libraries
- Document why dependencies were added

## Common Patterns

### Creating a New Panel
```typescript
import { Panel } from '../shared/Panel'
import { IconButton } from '../shared/IconButton'
import { Icon } from 'lucide-react'
import styles from './MyPanel.module.css'

export function MyPanel() {
  return (
    <Panel
      title="My Panel"
      icon={<Icon size={16} />}
      actions={<IconButton icon={<Icon />} />}
    >
      {/* Content */}
    </Panel>
  )
}
```

### Adding to Store
```typescript
// In store/editorStore.ts
interface EditorStore {
  // State
  myState: string
  
  // Actions
  setMyState: (value: string) => void
}

// In create() callback
myState: '',
setMyState: (value) => set({ myState: value }),
```

### Using Store in Component
```typescript
import { useEditorStore } from '../../store/editorStore'

export function MyComponent() {
  const myState = useEditorStore((state) => state.myState)
  const setMyState = useEditorStore((state) => state.setMyState)
  
  // Use state and actions
}
```

## Don't
- ❌ Don't use inline styles
- ❌ Don't mutate state directly
- ❌ Don't use var, always use const/let
- ❌ Don't ignore TypeScript errors
- ❌ Don't create deeply nested components
- ❌ Don't use magic numbers, use constants
- ❌ Don't skip prop validation
- ❌ Don't use index as key in lists (unless static)

## Do
- ✅ Use semantic HTML
- ✅ Keep components small and focused
- ✅ Use TypeScript strictly
- ✅ Follow consistent naming conventions
- ✅ Write self-documenting code
- ✅ Handle edge cases
- ✅ Provide user feedback
- ✅ Keep dependencies minimal
- ✅ Use CSS variables for theming
- ✅ Test edge cases

## Resources
- React Docs: https://react.dev
- TypeScript Docs: https://www.typescriptlang.org/docs
- Zustand Docs: https://github.com/pmndrs/zustand
- Lucide Icons: https://lucide.dev

